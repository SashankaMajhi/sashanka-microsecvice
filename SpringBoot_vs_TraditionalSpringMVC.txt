Spring Boot vs Traditional Spring MVC (Simple Sentences)


1. Traditional Spring MVC (Old Way)

-Server deployed the WAR file into Tomcat/WildFly.

-Tomcat/WildFly read the web.xml file after starting.

-web.xml configured the DispatcherServlet.

-DispatcherServlet can point to another XML config file (example: spring-servlet.xml) which contains Spring beans and controller mappings.

-That XML defined all controllers, URLs, and their method mappings (often with /* pattern).

-Then requests were handled using MVC (Controller → Service → DAO → View).

-This is the WAR + external server approach.

2. Spring Boot (Modern Way)

I run my JAR/WAR file with a main() method.

From the main method, Spring Boot uses @SpringBootApplication (meta-annotation that includes component scanning, auto-configuration, etc.).

Spring Boot scans all annotations (@RestController, @Service, @Repository, etc.) automatically.

Spring Boot starts an embedded Tomcat/Jetty inside the JAR/WAR.

DispatcherServlet is auto-configured (no web.xml needed).

Then the same MVC architecture works (Controller → Service → DAO → View).

This is the JAR + embedded server approach.

3. Common MVC Architecture
- Both ways use DispatcherServlet as the Front Controller.
- Both support Controllers, Services, Repositories, Views.
- Only the startup process differs.

4. JVM Thread Role
In Spring Boot → JVM main thread runs the main() method.

In Traditional WAR → JVM starts Tomcat, and Tomcat starts the web app.

For each request, Tomcat uses worker threads from its thread pool.

DispatcherServlet runs inside these worker threads to handle requests.
